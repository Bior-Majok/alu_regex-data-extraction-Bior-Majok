# ALU Regex Data Extraction Tool

A comprehensive Python-based data extraction tool using Regular Expressions to extract various data types from text responses. This tool is designed to process hundreds of thousands of pages of string responses from APIs and extract structured data efficiently.

##  Project Overview

This project implements a robust data extraction system that can identify and validate multiple data types within text content. It's built using Python's `re` module and provides both extraction and validation capabilities for 6 different data types.

##  Features

### Implemented Data Types (6/8)
- âœ… **Email Addresses** - `user@example.com`, `firstname.lastname@company.co.uk`
- âœ… **URLs** - `https://www.example.com`, `https://subdomain.example.org/page`
- âœ… **Phone Numbers** - `(123) 456-7890`, `123-456-7890`, `123.456.7890`
- âœ… **Credit Card Numbers** - `1234 5678 9012 3456`, `1234-5678-9012-3456`
- âœ… **Time Formats** - `14:30` (24-hour), `2:30 PM` (12-hour)
- âœ… **Currency Amounts** - `$19.99`, `$1,234.56`, `100 USD`

### Core Capabilities
- **Bulk Extraction**: Extract all data types from text in a single operation
- **Individual Extraction**: Extract specific data types as needed
- **Validation**: Validate individual data entries
- **Data Cleaning**: Utility functions for standardizing formats
- **Comprehensive Testing**: Extensive test cases and edge case handling

##  Installation

### Prerequisites
- Python 3.7 or higher
- pip (Python package manager)

### Setup
1. Clone the repository:
```bash
git clone https://github.com/your-username/alu_regex-data-extraction-YourUsername.git
cd alu_regex-data-extraction-YourUsername

Basic Usage
python
from data_extractor import DataExtractor

# Initialize the extractor
extractor = DataExtractor()

# Sample text containing various data types
sample_text = """
Contact us at support@example.com or call (555) 123-4567.
Visit https://www.example.com for more information.
Payment: $99.99 via card 1234-5678-9012-3456
Meeting at 2:30 PM or 14:30.
"""

# Extract all data types at once
results = extractor.extract_all(sample_text)

# Access specific data types
emails = results['emails']
urls = results['urls']
phone_numbers = results['phone_numbers']
Individual Extraction Methods
python
# Extract specific data types
emails = extractor.extract_emails(text)
urls = extractor.extract_urls(text)
phones = extractor.extract_phone_numbers(text)
credit_cards = extractor.extract_credit_cards(text)
time_formats = extractor.extract_time_formats(text)
currency = extractor.extract_currency(text)
Validation Methods
python
# Validate individual entries
is_valid_email = extractor.validate_email("test@example.com")
is_valid_phone = extractor.validate_phone("(123) 456-7890")
is_valid_url = extractor.validate_url("https://example.com")
is_valid_credit_card = extractor.validate_credit_card("1234-5678-9012-3456")
Utility Methods
python
# Clean and format extracted data
cleaned_card = extractor.clean_credit_card("1234-5678-9012-3456")
# Returns: "1234567890123456"

formatted_phone = extractor.format_phone_number("1234567890", "standard")
# Returns: "(123) 456-7890"
 Running the Demo
The package includes a comprehensive demonstration:

bash
python data_extractor.py
This will run the main demonstration showing:

Extraction of all 6 data types from sample text

Validation tests with both valid and invalid cases

Edge case handling examples

Extraction statistics and summary

 Regex Patterns Implemented
Email Addresses
regex
\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b
Supports: user@example.com, firstname.lastname@company.co.uk

Case-insensitive matching

URLs
regex
https?://(?:www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b(?:[-a-zA-Z0-9()@:%_\+.~#?&/=]*)
Supports: HTTP/HTTPS, with/without www, subdomains, paths

Phone Numbers
regex
(?:\(\d{3}\)\s?|\d{3}[-.]?)?\d{3}[-.]?\d{4}
Supports: (123) 456-7890, 123-456-7890, 123.456.7890, 1234567890

Credit Card Numbers
regex
\b(?:\d{4}[- ]?){3}\d{4}\b
Supports: 1234 5678 9012 3456, 1234-5678-9012-3456, 1234567890123456

Time Formats
24-hour: \b([01]?[0-9]|2[0-3]):[0-5][0-9]\b

12-hour: \b(1[0-2]|0?[1-9]):[0-5][0-9]\s?(?:AM|PM|am|pm)\b

Currency Amounts
regex
\$\d{1,3}(?:,\d{3})*(?:\.\d{2})?|\b\d+\s*(?:dollars|USD)\b
Supports: $19.99, $1,234.56, 100 USD, 50 dollars

 Project Structure
text
alu_regex-data-extraction-{YourUsername}/
â”‚
â”œâ”€â”€ data_extractor.py          # Main DataExtractor class
â”œâ”€â”€ README.md                  # Project documentation
â”œâ”€â”€ requirements.txt           # Python dependencies (none required)
â””â”€â”€ examples/                  # Usage examples (optional)
    â””â”€â”€ basic_usage.py
 Testing
The module includes comprehensive built-in testing:

python
# Run the comprehensive test suite
python data_extractor.py

# Expected output includes:
# - Extraction results from sample text
# - Validation tests with pass/fail status
# - Edge case handling demonstrations
# - Statistical summary of extracted data
ðŸ”§ API Reference
DataExtractor Class
Constructor
python
extractor = DataExtractor()
Main Methods
extract_all(text: str) -> Dict[str, Any] - Extract all data types

extract_emails(text: str) -> List[str] - Extract email addresses

extract_urls(text: str) -> List[str] - Extract URLs

extract_phone_numbers(text: str) -> List[str] - Extract phone numbers

extract_credit_cards(text: str) -> List[str] - Extract credit card numbers

extract_time_formats(text: str) -> Dict[str, List[str]] - Extract time formats

extract_currency(text: str) -> List[str] - Extract currency amounts

Validation Methods
validate_email(email: str) -> bool

validate_url(url: str) -> bool

validate_phone(phone: str) -> bool

validate_credit_card(card: str) -> bool

Utility Methods
clean_credit_card(card: str) -> str - Remove separators

format_phone_number(phone: str, format: str = "standard") -> str - Format phone number

 Error Handling
Returns empty lists when no matches are found

Handles malformed input gracefully

Provides clear validation results

Includes comprehensive edge case testing

 Performance
Optimized regex patterns for efficiency

Single-pass extraction where possible

Suitable for processing large volumes of text

Memory-efficient operations